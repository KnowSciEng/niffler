import java.io.{File, PrintWriter}

import scala.reflect.runtime.universe

/**
  * Automatically generate some code during "sbt compile"
  * @author rxue
  * @since 12/26/17.
  */
object CodeGenTokenSyntax {

  import universe._

  private def typeParameters(range: List[Int]): List[TypeDef] = {
    range.map(i => {
      TypeDef(Modifiers(), TypeName(s"T$i"), List.empty, TypeTree())
    })
  }

  private def tokenParameters(range: List[Int]): List[ValDef] = {
    range.map(i => {
      ValDef(Modifiers(), TermName(s"t$i"), q"Token[${TypeName(s"T$i")}]", EmptyTree)
    })
  }

  private def tokensWithoutType(range: List[Int]): List[Tree] = {
    range.map(i => {
      q"${Ident(TermName(s"t$i"))}"
    })
  }

  private def functionTypeParameter(range: List[Int]): List[Tree] = {
    range.map(i => {
      q"${TermName(s"T$i")}"
    })
  }

  private def getTokenFromCache(range: List[Int]): List[Tree] = {
    range.map(i => {
      q"cache(${Ident(TermName(s"t$i"))})"
    })
  }

  def requiresCodeGen(length: Int): Tree = {
    val range = Range(1, length + 1).toList
    q"""def requires[..${typeParameters(range)}, T]
          (..${tokenParameters(range)})
          (f: (..${functionTypeParameter(range)}) => T): TokenEvaluation[T] = {
          TokenEvaluation[T](Set(..${tokensWithoutType(range)}), 
                             (cache) => f(..${getTokenFromCache(range)}))
        }
     """
  }

  def dependsOnCodeGen(length: Int): Tree = {
    val range = Range(1, length + 1).toList
    q"""def dependsOn[..${typeParameters(range)}]
          (..${tokenParameters(range)})
          (f: (..${functionTypeParameter(range)}) => T): DirectImplementation[T] = {
          dependsOnEval(Niffler.requires(..${tokensWithoutType(range)})(f))
        }"""
  }

  def amendWithCodeGen(length: Int): Tree = {
    val range = Range(1, length + 1).toList
    q"""def amendWith[..${typeParameters(range)}, R]
          (..${tokenParameters(range)})
          (f: (..${functionTypeParameter(range)}) => R)
          (implicit canAmendTWithR: Append.Value[T, R]): 
          IncrementalImplementation[T, R] = {
          amendWithEval(Niffler.requires(..${tokensWithoutType(range)})(f))
        }"""
  }

  def nifflerSyntaxCodeGen(count: Int): Tree = {
    val evalFunctions = Range(1, count + 1).toList.map(requiresCodeGen)
    q"""
       trait NifflerSyntax {
        def constant[T](constant: => T): TokenEvaluation[T] = {
          TokenEvaluation(Set.empty, (cache) => constant)
        }
        
        ..$evalFunctions
       }
     """
  }

  def tokenSyntaxCodeGen(count: Int): Tree = {
    val dependsOnFunctions = Range(1, count + 1).toList.map(dependsOnCodeGen)
    val amendWithFunctions = Range(1, count + 1).toList.map(amendWithCodeGen)
    q"""
      trait TokenSyntax[T] {
        thisToken: Token[T] =>

        def asEval: TokenEvaluation[T] = {
          Niffler.requires(thisToken)(i => i)
        }

        def assign(constant: => T): DirectImplementation[T] = {
          dependsOnEval(Niffler.constant(constant))
        }

        def amendWith[R](constant: => R)
                        (implicit canAmendTWithR: Append.Value[T, R]): IncrementalImplementation[T, R] = {
          IncrementalImplementation(thisToken, Niffler.constant(constant), canAmendTWithR)
        }

        def dependsOnToken(token: Token[T]): DirectImplementation[T] = {
          dependsOnEval(token.asEval)
        }

        def amendWithToken[R](token: Token[R])
                             (implicit canAmendTWithR: Append.Value[T, R]): IncrementalImplementation[T, R] = {
          amendWithEval(token.asEval)
        }

        def dependsOnEval(eval: TokenEvaluation[T]): DirectImplementation[T] = {
          DirectImplementation(thisToken, eval)
        }

        def amendWithEval[R](eval: TokenEvaluation[R])
                            (implicit canAmendTWithR: Append.Value[T, R]): IncrementalImplementation[T, R] = {
          IncrementalImplementation(thisToken, eval, canAmendTWithR)
        }

        ..$dependsOnFunctions

        ..$amendWithFunctions
      }
      """
  }

  def generateCode(count: Int): Tree = {
    q"""
      package com.roboxue.niffler.syntax {
        import com.roboxue.niffler._
        import com.roboxue.niffler.execution.Append
       
        ..${nifflerSyntaxCodeGen(count)}

        ..${tokenSyntaxCodeGen(count)}
      }
      """
  }

  def saveToFile(srcFolder: File): File = {
    srcFolder.mkdirs()
    val file = new File(srcFolder, "com/roboxue/niffler/syntax/TokenSyntax.scala")
    file.getParentFile.mkdirs()
    val writer = new PrintWriter(file)
    try {
      // Function types with 23 arity aren't supported by scala
      writer.println("// auto generated by sbt compile")
      writer.write(showCode(generateCode(22)))
      file
    } finally {
      writer.close()
    }
  }
}
