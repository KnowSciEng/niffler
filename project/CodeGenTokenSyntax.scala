import java.io.{File, PrintWriter}

/**
  * Automatically generate some code during "sbt compile"
  * @author rxue
  * @since 12/26/17.
  */
object CodeGenTokenSyntax {

  import scala.reflect.runtime.universe
  import universe._

  def applyCodeGen(length: Int): Tree = {
    val range = Range(1, length + 1).toList
    val tparams: List[TypeDef] = TypeDef(Modifiers(), TypeName("R"), List.empty, TypeTree()) +: range.map(i => {
      TypeDef(Modifiers(), TypeName(s"T$i"), List.empty, TypeTree())
    })
    val functionTparams = range.map(i => {
      q"${TermName(s"T$i")}"
    })
    val params: List[List[ValDef]] = List(range.map(i => {
      ValDef(Modifiers(), TermName(s"t$i"), q"Token[${TypeName(s"T$i")}]", EmptyTree)
    }), List(ValDef(Modifiers(), TermName(s"f"), tq"(..$functionTparams)=>R", EmptyTree)))
    val tokens: List[List[Tree]] = List(range.map(i => {
      q"${Ident(TermName(s"t$i"))}"
    }))
    val tokenValues: List[List[Tree]] = List(range.map(i => {
      q"cache(${Ident(TermName(s"t$i"))})"
    }))
    q"""def apply[..$tparams](...$params): DirectImplementation[R] = {
          new DirectImplementation[R](Set(...$tokens), (cache) => f(...$tokenValues))
        }
     """
  }

  def dependsOnCodeGen(length: Int): Tree = {
    val range = Range(1, length + 1).toList
    val tparams: List[TypeDef] = range.map(i => {
      TypeDef(Modifiers(), TypeName(s"T$i"), List.empty, TypeTree())
    })
    val functionTparams = range.map(i => {
      q"${TermName(s"T$i")}"
    })
    val params: List[List[ValDef]] = List(range.map(i => {
      ValDef(Modifiers(), TermName(s"t$i"), q"Token[${TypeName(s"T$i")}]", EmptyTree)
    }), List(ValDef(Modifiers(), TermName(s"f"), tq"(..$functionTparams)=>R", EmptyTree)))
    val tokens: List[List[Tree]] = List(range.map(i => {
      q"${Ident(TermName(s"t$i"))}"
    }))
    q"""def dependsOn[..$tparams](...$params): Implementation[R] = {
          Implementation[R](thisToken, DependsOnTokens(...$tokens)(f))
        }
     """
  }

  def generateCode(count: Int): Tree = {
    val applyFunctions = Range(1, count + 1).toList.map(applyCodeGen)

    val dependsOnFunctions = Range(1, count + 1).toList.map(dependsOnCodeGen)

    q"""
      package com.roboxue.niffler.syntax {
        import com.roboxue.niffler.{DirectImplementation, ExecutionCache, Implementation, Token}
        
        object DependsOnTokens {
          def apply[R](value: => R): DirectImplementation[R] = {
            new DirectImplementation[R](Set.empty, (cache) => value)
          }
          
          ..$applyFunctions
        }
        
        trait TokenSyntax[R] {
          thisToken: Token[R] =>

          def assign(impl: => R): Implementation[R] = {
            Implementation(thisToken, DependsOnTokens(impl))
          }
          
          ..$dependsOnFunctions
        }
      }
      """
  }

  def saveToFile(srcFolder: File): File = {
    srcFolder.mkdirs()
    val file = new File(srcFolder, "com/roboxue/niffler/syntax/TokenSyntax.scala")
    file.getParentFile.mkdirs()
    val writer = new PrintWriter(file)
    try {
      // Function types with 23 arity aren't supported by scala
      writer.println("// auto generated by sbt compile")
      writer.write(showCode(generateCode(22)))
      file
    } finally {
      writer.close()
    }
  }
}
